# 03. 성격 유형 검사하기

* [문제 위치 : 프로그래머스](https://school.programmers.co.kr/learn/courses/30/lessons/118666)  
* [자바 소스](../../../CoTeStudy/src/programmers/Test03.java)  
 
### **문제 설명**

나만의 카카오 성격 유형 검사지를 만들려고 합니다.성격 유형 검사는 다음과 같은 4개 지표로 성격 유형을 구분합니다. 성격은 각 지표에서 두 유형 중 하나로 결정됩니다.

| 지표 번호 | 성격 유형 |
| --- | --- |
| 1번 지표 | 라이언형(R), 튜브형(T) |
| 2번 지표 | 콘형(C), 프로도형(F) |
| 3번 지표 | 제이지형(J), 무지형(M) |
| 4번 지표 | 어피치형(A), 네오형(N) |

4개의 지표가 있으므로 성격 유형은 총 16(=2 x 2 x 2 x 2)가지가 나올 수 있습니다. 예를 들어, "RFMN"이나 "TCMA"와 같은 성격 유형이 있습니다.

검사지에는 총 `n`개의 질문이 있고, 각 질문에는 아래와 같은 7개의 선택지가 있습니다.

- `매우 비동의`
- `비동의`
- `약간 비동의`
- `모르겠음`
- `약간 동의`
- `동의`
- `매우 동의`

각 질문은 1가지 지표로 성격 유형 점수를 판단합니다.

예를 들어, 어떤 한 질문에서 4번 지표로 아래 표처럼 점수를 매길 수 있습니다.

| 선택지 | 성격 유형 점수 |
| --- | --- |
| 매우 비동의 | 네오형 3점 |
| 비동의 | 네오형 2점 |
| 약간 비동의 | 네오형 1점 |
| 모르겠음 | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의 | 어피치형 1점 |
| 동의 | 어피치형 2점 |
| 매우 동의 | 어피치형 3점 |

이때 검사자가 질문에서 `약간 동의` 선택지를 선택할 경우 어피치형(A) 성격 유형 1점을 받게 됩니다. 만약 검사자가 `매우 비동의` 선택지를 선택할 경우 네오형(N) 성격 유형 3점을 받게 됩니다.

**위 예시처럼 네오형이 비동의, 어피치형이 동의인 경우만 주어지지 않고, 질문에 따라 네오형이 동의, 어피치형이 비동의인 경우도 주어질 수 있습니다.**하지만 각 선택지는 고정적인 크기의 점수를 가지고 있습니다.

- `매우 동의`나 `매우 비동의` 선택지를 선택하면 3점을 얻습니다.
- `동의`나 `비동의` 선택지를 선택하면 2점을 얻습니다.
- `약간 동의`나 `약간 비동의` 선택지를 선택하면 1점을 얻습니다.
- `모르겠음` 선택지를 선택하면 점수를 얻지 않습니다.

검사 결과는 모든 질문의 성격 유형 점수를 더하여 각 지표에서 더 높은 점수를 받은 성격 유형이 검사자의 성격 유형이라고 판단합니다. 단, 하나의 지표에서 각 성격 유형 점수가 같으면, 두 성격 유형 중 사전 순으로 빠른 성격 유형을 검사자의 성격 유형이라고 판단합니다.

질문마다 판단하는 지표를 담은 1차원 문자열 배열 `survey`와 검사자가 각 질문마다 선택한 선택지를 담은 1차원 정수 배열 `choices`가 매개변수로 주어집니다. 이때, 검사자의 성격 유형 검사 결과를 지표 번호 순서대로 return 하도록 solution 함수를 완성해주세요.

---

### 제한사항

- 1 ≤ `survey`의 길이 ( = `n`) ≤ 1,000
    - `survey`의 원소는 `"RT", "TR", "FC", "CF", "MJ", "JM", "AN", "NA"` 중 하나입니다.
    - `survey[i]`의 첫 번째 캐릭터는 i+1번 질문의 비동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.
    - `survey[i]`의 두 번째 캐릭터는 i+1번 질문의 동의 관련 선택지를 선택하면 받는 성격 유형을 의미합니다.
- `choices`의 길이 = `survey`의 길이
    - `choices[i]`는 검사자가 선택한 i+1번째 질문의 선택지를 의미합니다.
    - 1 ≤ `choices`의 원소 ≤ 7
    
    | choices | 뜻 |
    | --- | --- |
    | 1 | 매우 비동의 |
    | 2 | 비동의 |
    | 3 | 약간 비동의 |
    | 4 | 모르겠음 |
    | 5 | 약간 동의 |
    | 6 | 동의 |
    | 7 | 매우 동의 |

---

### 입출력 예

| survey | choices | result |
| --- | --- | --- |
| ["AN", "CF", "MJ", "RT", "NA"] | [5, 3, 2, 7, 5] | "TCMA" |
| ["TR", "RT", "TR"] | [7, 1, 3] | "RCJA" |

---

### 입출력 예 설명

**입출력 예 #1**

1번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지 | 성격 유형 점수 |
| --- | --- |
| 매우 비동의 | 어피치형 3점 |
| 비동의 | 어피치형 2점 |
| 약간 비동의 | 어피치형 1점 |
| 모르겠음 | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의 | 네오형 1점 |
| 동의 | 네오형 2점 |
| 매우 동의 | 네오형 3점 |

1번 질문에서는 지문의 예시와 다르게 비동의 관련 선택지를 선택하면 어피치형(A) 성격 유형의 점수를 얻고, 동의 관련 선택지를 선택하면 네오형(N) 성격 유형의 점수를 얻습니다.1번 질문에서 검사자는 `약간 동의` 선택지를 선택했으므로 네오형(N) 성격 유형 점수 1점을 얻게 됩니다.

2번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지 | 성격 유형 점수 |
| --- | --- |
| 매우 비동의 | 콘형 3점 |
| 비동의 | 콘형 2점 |
| 약간 비동의 | 콘형 1점 |
| 모르겠음 | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의 | 프로도형 1점 |
| 동의 | 프로도형 2점 |
| 매우 동의 | 프로도형 3점 |

2번 질문에서 검사자는 `약간 비동의` 선택지를 선택했으므로 콘형(C) 성격 유형 점수 1점을 얻게 됩니다.

3번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지 | 성격 유형 점수 |
| --- | --- |
| 매우 비동의 | 무지형 3점 |
| 비동의 | 무지형 2점 |
| 약간 비동의 | 무지형 1점 |
| 모르겠음 | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의 | 제이지형 1점 |
| 동의 | 제이지형 2점 |
| 매우 동의 | 제이지형 3점 |

3번 질문에서 검사자는 `비동의` 선택지를 선택했으므로 무지형(M) 성격 유형 점수 2점을 얻게 됩니다.

4번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지 | 성격 유형 점수 |
| --- | --- |
| 매우 비동의 | 라이언형 3점 |
| 비동의 | 라이언형 2점 |
| 약간 비동의 | 라이언형 1점 |
| 모르겠음 | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의 | 튜브형 1점 |
| 동의 | 튜브형 2점 |
| 매우 동의 | 튜브형 3점 |

4번 질문에서 검사자는 `매우 동의` 선택지를 선택했으므로 튜브형(T) 성격 유형 점수 3점을 얻게 됩니다.

5번 질문의 점수 배치는 아래 표와 같습니다.

| 선택지 | 성격 유형 점수 |
| --- | --- |
| 매우 비동의 | 네오형 3점 |
| 비동의 | 네오형 2점 |
| 약간 비동의 | 네오형 1점 |
| 모르겠음 | 어떤 성격 유형도 점수를 얻지 않습니다 |
| 약간 동의 | 어피치형 1점 |
| 동의 | 어피치형 2점 |
| 매우 동의 | 어피치형 3점 |

5번 질문에서 검사자는 `약간 동의` 선택지를 선택했으므로 어피치형(A) 성격 유형 점수 1점을 얻게 됩니다.

1번부터 5번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다.

| 지표 번호 | 성격 유형 | 점수 | 성격 유형 | 점수 |
| --- | --- | --- | --- | --- |
| 1번 지표 | 라이언형(R) | 0 | 튜브형(T) | 3 |
| 2번 지표 | 콘형(C) | 1 | 프로도형(F) | 0 |
| 3번 지표 | 제이지형(J) | 0 | 무지형(M) | 2 |
| 4번 지표 | 어피치형(A) | 1 | 네오형(N) | 1 |

각 지표에서 더 점수가 높은 `T`,`C`,`M`이 성격 유형입니다.하지만, 4번 지표는 1점으로 동일한 점수입니다. 따라서, 4번 지표의 성격 유형은 사전순으로 빠른 `A`입니다.

따라서 `"TCMA"`를 return 해야 합니다.

**입출력 예 #2**

1번부터 3번까지 질문의 성격 유형 점수를 합치면 아래 표와 같습니다.

| 지표 번호 | 성격 유형 | 점수 | 성격 유형 | 점수 |
| --- | --- | --- | --- | --- |
| 1번 지표 | 라이언형(R) | 6 | 튜브형(T) | 1 |
| 2번 지표 | 콘형(C) | 0 | 프로도형(F) | 0 |
| 3번 지표 | 제이지형(J) | 0 | 무지형(M) | 0 |
| 4번 지표 | 어피치형(A) | 0 | 네오형(N) | 0 |

1번 지표는 튜브형(T)보다 라이언형(R)의 점수가 더 높습니다. 따라서 첫 번째 지표의 성격 유형은 `R`입니다.하지만, 2, 3, 4번 지표는 모두 0점으로 동일한 점수입니다. 따라서 2, 3, 4번 지표의 성격 유형은 사전순으로 빠른 `C`, `J`, `A`입니다.

따라서 `"RCJA"`를 return 해야 합니다.

---

## 나의 접근 방법보다 다른 사람의 접근 방법

1. 각 지표를 의미있는 것들끼리 하나의 배열로 해서 모두 하나의 배열에 관리 될 수 있도록    
2차원 char 배열을 만들어 저장한다.  
2. choices 배열에 선택한 점수를 계산하기 쉽게   
score 배열을 생성하여 각 점수별로 대응되는 점수를 
choices에서 입력한 값과 인덱스가 대응하도록 맞추어 저장한다.
3. choices 배열에 입력된 점수와 지표가 맞춰져서 계산될 수 있게  
HashMap<Character, Integer> point 변수를 생성하여   
각 지표를 key로, key에 대한 value는 0으로 초기화해준다
4. 점수 기록을 위해 choices 배열의 길이만큼 반복문을 순회한다.
    1. choices[idx]의 값이 4보다 크면, 뒤쪽 지표에 해당하는 것
        1. 4보다 작으면 앞쪽 지표에 해당하는것
    2. 지표와 choices[idx]에 대응하는 점수를 score에서 찾아 point에 저장해준다
5. 지표에 따른 성격 유형을 출력하기 위해 type의 크기만큼 반복하여 값을 계산한다
    1. t[0]과 t[1]은 같은 레벨의 지표이기 때문에  
    둘 중 큰 값(같은 값이면 알파벳순 먼저 나오는 값)을 출력해준다.

## 다른 사람 코드

출처 : 프로그래머스 스쿨 - [다른사람 풀이 첫번째]([https://school.programmers.co.kr/learn/courses/30/lessons/42748/solution_groups?language=java](https://school.programmers.co.kr/learn/courses/30/lessons/118666/solution_groups?language=java))

```java
import java.util.HashMap;

class Solution {
    public String solution(String[] survey, int[] choices) {
        String answer = "";
        char [][] type = {{'R', 'T'}, {'C', 'F'}, {'J', 'M'}, {'A', 'N'}};
        int [] score = {0, 3, 2, 1, 0, 1, 2, 3};
        HashMap<Character, Integer> point = new HashMap<Character, Integer>();

        // 점수 기록할 배열 초기화 
        for (char[] t : type) {
            point.put(t[0], 0);
            point.put(t[1], 0);
        }

        // 점수 기록 
        for (int idx = 0; idx < choices.length; idx++){
            if(choices[idx] > 4){
                point.put(survey[idx].charAt(1), point.get(survey[idx].charAt(1)) + score[choices[idx]]);
            } else {
                point.put(survey[idx].charAt(0), point.get(survey[idx].charAt(0)) + score[choices[idx]]);
            }
        }

        // 지표 별 점수 비교 후 유형 기입
        for (char[] t : type) {
            answer += (point.get(t[1]) <= point.get(t[0])) ? t[0] : t[1];
        }

        return answer;
    }
}
```

### 1.  **사용할 변수들 생성 & 초기화**

```java
// 지표 2차 배열로 생성
// ➡️ 각 점수가 매겨지는 지표를 char 타입으로 각각 배열에 담음
char [][] type = {{'R', 'T'}, {'C', 'F'}, {'J', 'M'}, {'A', 'N'}};

// choices 숫자 별 점수를 배열로 등록
// ➡️ choices가 1~7 이기 때문에 계산하기 편하게 인덱스 1~7까지 해당되는 점수로 저장
int [] score = {0, 3, 2, 1, 0, 1, 2, 3};

// 점수 기록할 배열 생성 : HashMap<Character, Integer> point
// 점수 기록할 배열 초기화 : 모든 하나의 타입을 key로 하여 value를 0으로 초기화
HashMap<Character, Integer> point = new HashMap<Character, Integer>();
for (char[] t : type) {
    point.put(t[0], 0);
    point.put(t[1], 0);
}
```

### 2. **점수 기록**

```java
// 점수를 별도로 계산할 필요 없이, 위에서 만들어둔 score배열을 바로 가져다가 사용할 수 있음. 
// 단, 이때 점수를 등록할 타입이 0점이 아닐 수 있기때문에 get한 값과 더해서 저장해줌
for (int idx = 0; idx < choices.length; idx++){
    if(choices[idx] > 4){
        // 키는 choices가 4보다 크면 뒤쪽 타입에 대한 값이기 때문에 charAt(1)만 있으면 됨
        point.put(survey[idx].charAt(1), point.get(survey[idx].charAt(1)) + score[choices[idx]]);
    } else {
        // 키는 choices가 4보다 작으면 앞쪽 타입에 대한 값이기 때문에 charAt(0)만 있으면 됨
        point.put(survey[idx].charAt(0), point.get(survey[idx].charAt(0)) + score[choices[idx]]);
    }
}
```

### 3. **지표 별 점수 비교 후 유형 기입**

```java
// point에서 t[1]과 t[2]의 값을 비교해서 더 큰 값이 나오는 t를 answer에 기록
for (char[] t : type) {
    answer += (point.get(t[1]) <= point.get(t[0])) ? t[0] : t[1];
}
```

## 내 코드

```java
import java.util.*;
class Solution {
    public String solution(String[] survey, int[] choices) {
        String answer = "";
        String[] arrS = new String[]{"RT","CF","JM","AN"};
        HashMap<String, Integer[]> table = new HashMap();
        for (String s: arrS) {
            table.put(s, new Integer[]{0,0});
        }

        int idx = 0;
        Integer[] temp;
        for (String s: survey) {
            if (choices[idx] != 4) {
                if (s.contains("R"))            temp = table.get("RT");
                else if (s.contains("C"))       temp = table.get("CF");
                else if (s.contains("J"))       temp = table.get("JM");
                else                            temp = table.get("AN");

                int idxType;
                if (s.charAt(0) == 'R' || s.charAt(0) == 'C' || 
                	s.charAt(0) == 'J' || s.charAt(0) == 'A' ) {
                    idxType = choices[idx] > 4 ? 1 : 0;
                } else {
                    idxType = choices[idx] > 4 ? 0 : 1;
                }

                if (choices[idx] > 4) {
                    temp[idxType] += choices[idx] - 4;
                } else {
                    temp[idxType] += 4 - choices[idx];
                }
                table.put(s, temp);
            } 
            
            idx++;
        }

        for (String s : arrS) {
            temp = table.get(s);
            if (temp[0] >= temp[1]) answer += s.charAt(0);
            else answer += s.charAt(1);
        }
        return answer;
    }
}
```

### 느낀점

이번 문제는 메모로 시작하여   

코드의 방향이 보이고 나서 키보드에 손을 올렸던 문제였다.  

내가 메모하는 습관이 없었는데,  그래서 놓치는 부분도 생기고 집중력도 잘 흐트러지고 

코드를 작성하다가 방향을 잃은적도 몇번 있었다.

메모를 하고 코드를 작성해보니 정말 좋았다.

물론 습관이 되어있지 않아서 메모를 시작할때 어떻게 시작해야하지..

뭐부터 적어야 하지.. 하는 고민들이 정말 많았고

다 하고 난 지금 메모했던걸 다시보면 형편없는게 적혀있기도 하고 ㅋㅋ

조금 더 생각해봤더라면 좋았을 부분도 보이긴 하는데

그래도 메모하지 않고 코드를 작성했다면 

이 문제를 오늘 풀어낸 시간안에 절대 못 풀었을것이다.

아직 부족한 부분이 많지만 꾸준히 하다보면 좋은 변화가 생기겠지! 😊  

그리고 프로그래머스는 풀고 난 후에 다른 사람들의 코드를 보여줘서 정말 좋다.

혼자서 공부해도 배울점을 얻을 수 있다는것! 

화이팅💪